# -*- coding: utf-8 -*-
"""Python_Section_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TrGmrK5Ol5_xkDee6KzO2yCzecUWSipp

####Question 1: Reverse List by N Elements
"""

def reverse_by_n(lst, n):
    result = lst[:]                                                              # we can give our input here or below
    for i in range(0, len(lst), n):
        left, right = i, min(i + n - 1, len(lst) - 1)
        while left < right:
            result[left], result[right] = result[right], result[left]
            left += 1
            right -= 1
    return result

# Input ONE
my_list_1 = [1, 2, 3, 4, 5, 6, 7, 8]
n = 3

# Call the function
result = reverse_by_n(my_list_1, n)
print(result)

# Input TWO
my_list_2 = [1, 2, 3, 4, 5]
n = 2

# Call the function
result = reverse_by_n(my_list_2, n)
print(result)

# Input THREE
my_list_3 = [10, 20, 30, 40, 50, 60, 70]
n = 4

# Call the function
result = reverse_by_n(my_list_3, n)
print(result)

"""####Question 2: Lists & Dictionaries"""

def group_by_length(strings):
    length_dict = {}

    for word in strings:
        length = len(word)
        if length not in length_dict:
            length_dict[length] = []
        length_dict[length].append(word)
    return dict(sorted(length_dict.items()))

# Input 1
string_1 = ["apple", "bat", "car", "elephant", "dog", "bear"]
result = group_by_length(string_1)
print(result)

# Input 2
string_2 = ["one", "two", "three", "four"]
result = group_by_length(string_2)
print(result)

"""####Question 3: Flatten a Nested Dictionary"""

def flatten_dict(d):
    flat_dict = {}

    def flatten(current_dict, parent_key=''):
        for key, value in current_dict.items():
            new_key = f"{parent_key}.{key}" if parent_key else key

            if isinstance(value, dict):
                flatten(value, new_key)
            elif isinstance(value, list):
                for i, item in enumerate(value):
                    flatten({f"{key}[{i}]": item}, parent_key)
            else:
                flat_dict[new_key] = value

    flatten(d)
    return flat_dict

nested_dict = {
    "road": {
        "name": "Highway 1",
        "length": 350,
        "sections": [
            {
                "id": 1,
                "condition": {
                    "pavement": "good",
                    "traffic": "moderate"
                }
            }
        ]
    }
}
flattened = flatten_dict(nested_dict)
print(flattened)



"""####Question 4: Generate Unique Permutations"""

from itertools import permutations

def unique_permutations(lst):
    return list(set(permutations(lst)))
input_list = [1, 2, 2]
result = unique_permutations(input_list)
print(result)

"""####Question 5: Find All Dates in a Text"""

import re

def find_all_dates(text):
    date_patterns = [
        r'\d{2}-\d{2}-\d{4}',
        r'\d{2}/\d{2}/\d{4}',
        r'\d{4}\.\d{2}\.\d{2}'
    ]
    dates = []
    for pattern in date_patterns:
        dates.extend(re.findall(pattern, text))
    return dates

text = "I was born on 23-08-1994, my friend on 08/23/1994, and another one on 1994.08.23."
found_dates = find_all_dates(text)
print(found_dates)

"""####Question 6: Decode Polyline, Convert to DataFrame with Distances"""

!pip install polyline

import polyline
import pandas as pd
import math

def decode_polyline_to_dataframe(polyline_str):
    try:
        coords = polyline.decode(polyline_str)
    except (IndexError, ValueError) as e:
        print(f"Error decoding polyline: {e}")
        return pd.DataFrame(columns=['latitude', 'longitude', 'distance'])

    df = pd.DataFrame(coords, columns=['latitude', 'longitude'])

    def haversine(lat1, lon1, lat2, lon2):
        R = 6371000
        phi1, phi2 = map(math.radians, [lat1, lat2])
        dphi = math.radians(lat2 - lat1)
        dlambda = math.radians(lon2 - lon1)
        a = math.sin(dphi/2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda/2)**2
        return 2 * R * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    df['distance'] = [0] + [haversine(df.iloc[i-1]['latitude'], df.iloc[i-1]['longitude'], row['latitude'], row['longitude'])
                            for i, row in df.iterrows() if i > 0]

    return df

# Example usage:
polyline_str = '_p~iF~ps|U_ulLnnqC_mqNvxq`@'
df = decode_polyline_to_dataframe(polyline_str)
print(df)

"""####Question 7: Matrix Rotation and Transformation"""

def rotate_and_transform(matrix):
    n = len(matrix)
    rotated = [[matrix[n-j-1][i] for j in range(n)] for i in range(n)]
    transformed = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            row_sum = sum(rotated[i]) - rotated[i][j]
            col_sum = sum(rotated[k][j] for k in range(n)) - rotated[i][j]
            transformed[i][j] = row_sum + col_sum
    return transformed

matrix = [[1, 2, 3],[4, 5, 6],[7, 8, 9]]
print(rotate_and_transform(matrix))

"""####Question 8: Time Check"""

import pandas as pd
dataset = pd.read_csv("/content/dataset-1.csv")
def check_completeness(df):
    grouped = df.groupby(['id', 'id_2'])
    result = pd.Series(False, index=grouped.groups.keys(), name="is_incomplete")

    for key, group in grouped:
        days_covered = set(group['startDay'].unique())
        if len(days_covered) == 7:
            result[key] = False
        else:
            result[key] = True

    return result

completeness_check = check_completeness(dataset)
print(completeness_check)

dataset.head()

completeness_check.head()

